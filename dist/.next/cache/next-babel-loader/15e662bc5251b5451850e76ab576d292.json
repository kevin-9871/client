{"ast":null,"code":"import _toConsumableArray from \"@babel/runtime/helpers/esm/toConsumableArray\";\nimport _regeneratorRuntime from \"@babel/runtime/regenerator\";\nimport _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport _asyncToGenerator from \"@babel/runtime/helpers/esm/asyncToGenerator\";\nimport _slicedToArray from \"@babel/runtime/helpers/esm/slicedToArray\";\nimport _objectWithoutProperties from \"@babel/runtime/helpers/esm/objectWithoutProperties\";\nimport _classCallCheck from \"@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/esm/createClass\";\nimport _inherits from \"@babel/runtime/helpers/esm/inherits\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/esm/getPrototypeOf\";\nvar _excluded = [\"editable\", \"children\", \"record\", \"handleSave\"];\nvar __jsx = React.createElement;\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\n/* eslint-disable jsx-a11y/no-static-element-interactions */\n\n/* eslint-disable jsx-a11y/click-events-have-key-events */\nimport * as React from 'react';\nimport { Table, Tag, Select, message } from 'antd';\nimport { formatDate, getResponseError } from 'src/lib';\nimport { studioService } from 'src/services';\nimport { EditOutlined } from '@ant-design/icons';\nexport var StatusTitle = /*#__PURE__*/function (_React$PureComponent) {\n  _inherits(StatusTitle, _React$PureComponent);\n\n  var _super = _createSuper(StatusTitle);\n\n  function StatusTitle() {\n    _classCallCheck(this, StatusTitle);\n\n    return _super.apply(this, arguments);\n  }\n\n  _createClass(StatusTitle, [{\n    key: \"render\",\n    value: function render() {\n      return __jsx(EditOutlined, null);\n    }\n  }]);\n\n  return StatusTitle;\n}(React.PureComponent);\nvar Option = Select.Option;\nvar STUDIO_PAYOUT_REQUEST_STATUS = [{\n  lable: 'Pending',\n  key: 'pending'\n}, {\n  lable: 'Approved',\n  key: 'approved'\n}, {\n  lable: 'Rejected',\n  key: 'rejected'\n}, {\n  lable: 'Done',\n  key: 'done'\n}];\n\nvar EditableCell = function EditableCell(_ref) {\n  var editable = _ref.editable,\n      children = _ref.children,\n      record = _ref.record,\n      handleSave = _ref.handleSave,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  var _React$useState = React.useState(false),\n      _React$useState2 = _slicedToArray(_React$useState, 2),\n      editing = _React$useState2[0],\n      setEditing = _React$useState2[1];\n\n  var childNode = children;\n\n  var toggleEdit = function toggleEdit() {\n    setEditing(!editing);\n  };\n\n  if (editable) {\n    childNode = editing ? __jsx(Select, {\n      defaultValue: record.status,\n      onChange: /*#__PURE__*/function () {\n        var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(value) {\n          return _regeneratorRuntime.wrap(function _callee$(_context) {\n            while (1) {\n              switch (_context.prev = _context.next) {\n                case 0:\n                  _context.next = 2;\n                  return handleSave(_objectSpread(_objectSpread({}, record), {}, {\n                    status: value\n                  }));\n\n                case 2:\n                  toggleEdit();\n\n                case 3:\n                case \"end\":\n                  return _context.stop();\n              }\n            }\n          }, _callee);\n        }));\n\n        return function (_x) {\n          return _ref2.apply(this, arguments);\n        };\n      }()\n    }, STUDIO_PAYOUT_REQUEST_STATUS.map(function (s) {\n      return __jsx(Option, {\n        key: s.key,\n        value: s.key\n      }, s.lable);\n    })) : __jsx(\"div\", {\n      className: \"\",\n      style: {\n        paddingRight: 24,\n        cursor: 'pointer'\n      },\n      onMouseEnter: toggleEdit,\n      onClick: toggleEdit\n    }, children);\n  }\n\n  return __jsx(\"td\", props, childNode);\n};\n\nvar breakPoint = ['md'];\nvar format = 'DD/MM/YYYY';\n\nvar PayoutRequestList = function PayoutRequestList(_ref3) {\n  var payouts = _ref3.payouts,\n      searching = _ref3.searching,\n      total = _ref3.total,\n      pageSize = _ref3.pageSize,\n      onChange = _ref3.onChange;\n\n  var _React$useState3 = React.useState([]),\n      _React$useState4 = _slicedToArray(_React$useState3, 2),\n      dataSource = _React$useState4[0],\n      setDataSource = _React$useState4[1];\n\n  var columns = [{\n    title: 'Name',\n    key: 'q',\n    dataIndex: 'performerInfo',\n    render: function render(_ref4) {\n      var name = _ref4.name;\n      return name;\n    }\n  }, {\n    title: 'Pay Period',\n    key: 'payPeriod',\n    responsive: breakPoint,\n    render: function render(_ref5) {\n      var fromDate = _ref5.fromDate,\n          toDate = _ref5.toDate;\n      return __jsx(\"span\", null, formatDate(fromDate, format), ' ', \"-\", formatDate(toDate, format));\n    },\n    editable: false\n  }, {\n    title: 'Payment Account Type',\n    key: 'paymentAccountType',\n    dataIndex: 'paymentAccountType',\n    editable: false\n  }, {\n    title: 'Tokens',\n    key: 'tokenMustPay',\n    dataIndex: 'tokenMustPay',\n    editable: false\n  }, {\n    title: 'Status',\n    dataIndex: 'status',\n    key: 'status',\n    render: function render(status) {\n      return __jsx(Tag, {\n        color: \"magenta\",\n        style: {\n          cursor: 'pointer'\n        }\n      }, status);\n    },\n    editable: true\n  }, {\n    title: 'Date Requested',\n    key: 'createdAt',\n    dataIndex: 'createdAt',\n    render: function render(createdAt) {\n      return __jsx(\"span\", null, formatDate(createdAt));\n    },\n    sorter: true,\n    editable: false\n  }];\n\n  var save = /*#__PURE__*/function () {\n    var _ref6 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(request) {\n      var newData, item, error;\n      return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n        while (1) {\n          switch (_context2.prev = _context2.next) {\n            case 0:\n              _context2.prev = 0;\n              _context2.next = 3;\n              return studioService.updateStatusPerformerRequest(request._id, {\n                status: request.status\n              });\n\n            case 3:\n              newData = _toConsumableArray(dataSource);\n              item = newData.find(function (d) {\n                return d.key === request._id;\n              });\n              item.status = request.status;\n              setDataSource(newData);\n              message.success('Update Status Success');\n              _context2.next = 16;\n              break;\n\n            case 10:\n              _context2.prev = 10;\n              _context2.t0 = _context2[\"catch\"](0);\n              _context2.next = 14;\n              return Promise.resolve(_context2.t0);\n\n            case 14:\n              error = _context2.sent;\n              message.error(getResponseError(error));\n\n            case 16:\n            case \"end\":\n              return _context2.stop();\n          }\n        }\n      }, _callee2, null, [[0, 10]]);\n    }));\n\n    return function save(_x2) {\n      return _ref6.apply(this, arguments);\n    };\n  }();\n\n  var mergeColumn = columns.map(function (c) {\n    return _objectSpread(_objectSpread({}, c), {}, {\n      onCell: function onCell(record) {\n        return {\n          record: record,\n          editable: c.editable,\n          dataIndex: c.dataIndex,\n          title: c.title,\n          handleSave: save\n        };\n      }\n    });\n  });\n  React.useEffect(function () {\n    setDataSource(payouts.map(function (p) {\n      return _objectSpread(_objectSpread({}, p), {}, {\n        key: p._id\n      });\n    }));\n  }, [payouts]);\n  return __jsx(Table, {\n    dataSource: dataSource,\n    components: {\n      body: {\n        cell: EditableCell\n      }\n    },\n    rowClassName: function rowClassName() {\n      return 'editable-row';\n    },\n    columns: mergeColumn,\n    className: \"table\",\n    pagination: {\n      total: total,\n      pageSize: pageSize\n    },\n    scroll: {\n      x: true\n    },\n    showSorterTooltip: false,\n    loading: searching,\n    onChange: onChange\n  });\n};\n\nexport default PayoutRequestList;","map":null,"metadata":{},"sourceType":"module"}