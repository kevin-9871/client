{"ast":null,"code":"var __jsx = React.createElement;\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n/* eslint-disable dot-notation */\nimport React, { PureComponent } from 'react';\nimport Head from 'next/head';\nimport { Row, Col, Button, message } from 'antd';\nimport { connect } from 'react-redux';\nimport { messageService, performerService, streamService } from 'src/services';\nimport LivePublisher from '@components/streaming/publisher';\nimport { SocketContext, Event } from 'src/socket';\nimport { getStreamConversation, resetStreamMessage, resetAllStreamMessage } from '@redux/stream-chat/actions';\nimport { updateStreamingStatus } from '@redux/performer/actions';\nimport { WEBRTC_ADAPTOR_INFORMATIONS } from 'src/antmedia/constants';\nimport ChatBox from '@components/stream-chat/chat-box';\nimport UpdateSatusForm from '@components/performer/streaming-status-update-form';\nimport Router from 'next/router';\nimport { getResponseError } from '@lib/utils';\nimport './index.less'; // eslint-disable-next-line no-shadow\n\nvar EVENT_NAME;\n\n(function (EVENT_NAME) {\n  EVENT_NAME[\"ROOM_INFORMATIOM_CHANGED\"] = \"public-room-changed\";\n  EVENT_NAME[\"USER_LEFT_ROOM\"] = \"USER_LEFT_ROOM\";\n})(EVENT_NAME || (EVENT_NAME = {}));\n\nclass PerformerLivePage extends PureComponent {\n  constructor(props) {\n    super(props);\n\n    _defineProperty(this, \"publisherRef\", void 0);\n\n    _defineProperty(this, \"blockedUserIds\", []);\n\n    _defineProperty(this, \"socket\", void 0);\n\n    _defineProperty(this, \"onbeforeunload\", () => {\n      this.leavePublicRoom();\n    });\n\n    this.state = {\n      loading: false,\n      initialized: false,\n      sessionId: '',\n      total: 0,\n      members: []\n    };\n  }\n\n  componentDidMount() {\n    this.socket = this.context;\n    this.joinPublicRoom();\n    window.addEventListener('beforeunload', this.onbeforeunload);\n    Router.events.on('routeChangeStart', this.onbeforeunload);\n  }\n\n  componentDidUpdate(prevProps) {\n    const {\n      updateSuccess,\n      updateError\n    } = this.props;\n\n    if (prevProps.updateSuccess !== updateSuccess && updateSuccess) {\n      message.success('Update Status Success.');\n    }\n\n    if (prevProps.updateError !== updateError && updateError) {\n      message.error(getResponseError(updateError));\n    }\n  }\n\n  componentWillUnmount() {\n    window.removeEventListener('beforeunload', this.onbeforeunload);\n    Router.events.off('routeChangeStart', this.onbeforeunload);\n  }\n\n  handler({\n    total,\n    members,\n    conversationId\n  }) {\n    var _activeConversation$d;\n\n    const {\n      activeConversation\n    } = this.props;\n\n    if (activeConversation !== null && activeConversation !== void 0 && (_activeConversation$d = activeConversation.data) !== null && _activeConversation$d !== void 0 && _activeConversation$d._id && activeConversation.data._id === conversationId) {\n      this.setState({\n        total,\n        members\n      });\n    }\n  }\n\n  handleUpdateStatusForm(data) {\n    const {\n      updateStreamingStatus: dispatchUpdateStreamingStatus\n    } = this.props;\n    dispatchUpdateStreamingStatus(data);\n  }\n\n  async getBlockedList() {\n    try {\n      const resp = await performerService.getBlockedList();\n      this.blockedUserIds = resp.data.userIds;\n    } catch (e) {\n      const error = await Promise.resolve(e);\n      message.error(getResponseError(error));\n    }\n  }\n\n  async start() {\n    try {\n      this.setState({\n        loading: true\n      });\n      const resp = await streamService.goLive();\n      const id = resp.data.sessionId;\n      this.setState({\n        sessionId: id\n      });\n      this.publisherRef && this.publisherRef.start();\n    } catch (e) {\n      const error = await Promise.resolve(e);\n      message.error(getResponseError(error));\n    } finally {\n      this.setState({\n        loading: false\n      });\n    }\n  }\n\n  callback(info) {\n    const {\n      activeConversation\n    } = this.props;\n    const {\n      sessionId\n    } = this.state;\n\n    if (activeConversation && activeConversation.data) {\n      this.socket = this.context;\n\n      if (info === WEBRTC_ADAPTOR_INFORMATIONS.INITIALIZED) {\n        this.setState({\n          initialized: true\n        }); // window['webRTCAdaptor'].publish(sessionId);\n\n        this.publisherRef && this.publisherRef.publish(sessionId);\n      } else if (info === WEBRTC_ADAPTOR_INFORMATIONS.PUBLISH_STARTED) {\n        const conversation = _objectSpread({}, activeConversation.data);\n\n        this.socket.emit('public-stream/live', {\n          conversationId: conversation._id\n        });\n        this.setState({\n          loading: false\n        });\n      } else if (info === WEBRTC_ADAPTOR_INFORMATIONS.PUBLISH_FINISHED) {\n        this.setState({\n          loading: false\n        });\n      } else if (info === WEBRTC_ADAPTOR_INFORMATIONS.CLOSED) {\n        this.setState({\n          loading: false,\n          initialized: false\n        });\n      }\n    }\n  }\n\n  async joinPublicRoom() {\n    const {\n      getStreamConversation: dispatchGetStreamConversation\n    } = this.props;\n    this.socket = this.context;\n\n    try {\n      this.setState({\n        loading: true\n      });\n      const resp = await streamService.goLive();\n      const {\n        conversation\n      } = resp.data;\n\n      if (conversation && conversation._id) {\n        dispatchGetStreamConversation({\n          conversation\n        });\n        this.socket && this.socket.emit('public-stream/join', {\n          conversationId: conversation._id\n        });\n      }\n    } catch (e) {\n      const error = await Promise.resolve(e);\n      message.error(getResponseError(error));\n    } finally {\n      this.setState({\n        loading: false\n      });\n    }\n  }\n\n  leavePublicRoom() {\n    const {\n      activeConversation,\n      resetStreamMessage: reset\n    } = this.props;\n\n    if (this.socket && activeConversation && activeConversation.data) {\n      const conversation = _objectSpread({}, activeConversation.data);\n\n      this.socket.emit('public-stream/leave', {\n        conversationId: conversation._id\n      });\n      reset();\n    }\n  }\n\n  userLeftRoomHandle({\n    username,\n    conversationId\n  }) {\n    var _activeConversation$d2;\n\n    const {\n      activeConversation\n    } = this.props;\n\n    if (activeConversation !== null && activeConversation !== void 0 && (_activeConversation$d2 = activeConversation.data) !== null && _activeConversation$d2 !== void 0 && _activeConversation$d2._id && conversationId === activeConversation.data._id) {\n      const {\n        total,\n        members\n      } = this.state;\n      this.setState({\n        total: total - 1,\n        members: members.filter(m => m.username !== username)\n      });\n    }\n  }\n\n  async removeAllMessage() {\n    const {\n      activeConversation,\n      performer,\n      resetAllStreamMessage: dispatchResetAllMessage\n    } = this.props;\n\n    if (!activeConversation.data || performer._id !== activeConversation.data.performerId) {\n      return;\n    }\n\n    try {\n      if (!window.confirm('Are you sure you want to remove chat history?')) {\n        return;\n      }\n\n      await messageService.deleteAllMessageInConversation(activeConversation.data._id);\n      dispatchResetAllMessage({\n        conversationId: activeConversation.data._id\n      });\n    } catch (e) {\n      const error = await Promise.resolve(e);\n      message.error(getResponseError(error));\n    }\n  }\n\n  async blockUser(id) {\n    if (!window.confirm('Are you sure to block this user?')) return;\n\n    try {\n      const {\n        members,\n        total\n      } = this.state;\n      this.blockedUserIds = [...this.blockedUserIds, id];\n      await performerService.geoBlock({\n        userIds: this.blockedUserIds\n      });\n      this.setState({\n        total: total - 1,\n        members: members.filter(m => m._id !== id)\n      });\n    } catch (e) {\n      const error = await Promise.resolve(e);\n      message.error(getResponseError(error));\n    }\n  }\n\n  render() {\n    const {\n      performer,\n      activeConversation,\n      updating\n    } = this.props;\n    const {\n      loading,\n      initialized,\n      members,\n      total\n    } = this.state;\n    return __jsx(React.Fragment, null, __jsx(Head, null, __jsx(\"title\", null, \"Go Live\")), __jsx(Event, {\n      event: EVENT_NAME.ROOM_INFORMATIOM_CHANGED,\n      handler: this.handler.bind(this)\n    }), __jsx(Event, {\n      event: EVENT_NAME.USER_LEFT_ROOM,\n      handler: this.userLeftRoomHandle.bind(this)\n    }), __jsx(Row, null, __jsx(Col, {\n      xs: 24,\n      sm: 24,\n      md: 12\n    }, __jsx(UpdateSatusForm, {\n      status: performer.streamingTitle,\n      updating: updating,\n      submit: this.handleUpdateStatusForm.bind(this)\n    }), !initialized && __jsx(Button, {\n      type: \"primary\",\n      onClick: this.start.bind(this),\n      loading: loading,\n      block: true\n    }, \"Start Streaming\"), __jsx(LivePublisher, _extends({}, this.props, {\n      participantId: performer._id // eslint-disable-next-line no-return-assign\n      ,\n      ref: ref => this.publisherRef = ref,\n      callback: this.callback.bind(this),\n      configs: {\n        debug: true,\n        bandwidth: 900,\n        localVideoId: 'publisher'\n      }\n    }))), __jsx(Col, {\n      xs: 24,\n      sm: 24,\n      md: 12\n    }, __jsx(ChatBox, _extends({}, this.props, {\n      members: members,\n      totalParticipant: total,\n      currentPerformer: performer,\n      blockUser: this.blockUser.bind(this)\n    })), (activeConversation === null || activeConversation === void 0 ? void 0 : activeConversation.data) && __jsx(\"div\", {\n      style: {\n        margin: '10px'\n      }\n    }, __jsx(Button, {\n      type: \"primary\",\n      onClick: this.removeAllMessage.bind(this)\n    }, \"Clear message history\")))));\n  }\n\n}\n\n_defineProperty(PerformerLivePage, \"authenticate\", true);\n\nPerformerLivePage.contextType = SocketContext;\n\nconst mapStateToProps = state => _objectSpread(_objectSpread({}, state.streaming), {}, {\n  performer: state.performer.current,\n  updating: state.performer.updating,\n  updateSuccess: state.performer.updateSuccess,\n  updateError: state.performer.updateError,\n  activeConversation: state.streamMessage.activeConversation,\n  loggedIn: state.auth.loggedIn\n});\n\nconst mapDispatchs = {\n  updateStreamingStatus,\n  getStreamConversation,\n  resetStreamMessage,\n  resetAllStreamMessage\n};\nexport default connect(mapStateToProps, mapDispatchs)(PerformerLivePage);","map":null,"metadata":{},"sourceType":"module"}